타입 : 어떤 값의 유형 및 종류
해당 메모리가 메모리에 어떻게 저장되고, 프로그램에서 어떻게 처리되어야 하는지를 명시적으로 알려준다.
타입에 따라 값이 차지하는 메모리 공간의 크기와, 값이 저장되는 방식이 결정된다.
	값이 차지하는 메모리 공간의 크기 
  ex: 정수형 타입의 데이터는 4byte, 문자형 타입의 데이터는 1byte
	값이 저장되는 방식
    	: 저장하고자 하는 값을 그대로 저장하는 **기본타입** & 
          저장하고자 하는 값을 임의의 메모리 공간에 저장한 후, 그 메모리 공간의 주소를 저장하는 **참조타입**
          
---

| 프리미티브 타입 종류와 값의 범위 그리고 기본 값
| 프리미티브 타입과 레퍼런스 타입 

---

## ▶️ 기본 타입(primitive type)
	'실제 값' 을 의미한다.
    값 그 자체를 저장한다.

> - 실제 값을 저장하는 공간으로 스택(Stack) 메모리에 저장된다.
- 컴파일 시점에 담을 수 있는 크기를 벗어나면 에러를 발생시키는 컴파일 에러가 발생한다.

**^ 종류 ^**
정수 타입(byte,short,int,long),실수 타입(float,double),문자 타입(char),논리 타입(boolean)

**^ 데이터 크기와 기본값 ^**
기본값이 있기 때문에 'Null'이 존재하지 않는다.
만약, Null을 넣고 싶다면 래퍼 클래스를 활용해야 한다.

```
cf)
Wrapper Class(래퍼 클래스)
	8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스.
	래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 
    해당 값을 가지는 객체로 만들어 준다.
	래퍼 클래스는 모두 java.lang 패키지에 포함되어 제공된다.

                  기본타입 : 래퍼 클래스
                    byte : Byte
                   short : Short
                     int : Integer
                    long : Long
                   float : Float
                  double : Double
                    char : Character
                 boolean : Boolean
                 
    래퍼 클래스는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없다.
    단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있다.
    
    cf) 인스턴스
    설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
    -> 객체를 소프트웨어에 실체화하면 그것을 '인스턴스'라고 부른다.
    설계화된 인스턴스는 메모리에 할당된다.
```

![](https://velog.velcdn.com/images/bokimy/post/e7586eb0-707f-4ae6-b334-b661d7287a73/image.png)

과거에는 메모리 용량이 넉넉하지 않아 필요에 따라 변수의 자료 범위를 변경해야 했지만, 현재는 메모리 용량이 부족한 경우가 거의 없기 때문에 정수형을 사용할 때 일반적으로 ``ìnt``형을 사용한다.

1byte=8bit
컴퓨터는 2진수 언어이므로 한자리에 0 혹은 1이 들어갈 수 있다.
제일 앞은 음수 혹은 양수를 표현해야 하므로 1bit를 사용하면 남은 7bit로는 '2의 7제곱 = 128개'의 숫자를 표현할 수 있다.
그러므로, 1byte로는 -128~127의 표현이 가능한 것이다.


**^ 유의사항 ^**

🟡 정수형 타입
- 결정할 때, 사용하려는 데이터의 최대/최소 표현 범위를 고려해야 한다. 
- 범위를 벗어난 데이터를 저장하면 오버플로우(overflow) 또는 언더플로우(underflow)가 발생해 엉뚱한 값이 저장될 수 있기 때문이다.
- 오버플로우의 경우, 해당 데이터 타입의 최소값으로 값이 순환된다.
    	ex) byte : 128 -> -127로 표현된다.
- 언더플로우의 경우, 최소값을 넘어가면 해당 데이터 타입의 최대값으로 값이 순환된다.
    	ex) byte : -129 -> 127로 표현된다.
``` 
cf) 
오버플로우(overflow) : 해당 타입이 표현할 수 있는 '최대 표현 범위'보다 큰 수를 저장할 때 발생하는 현상
언더플로우(underflow) : 해당 타입이 표현할 수 있는 '최소 표현 범위'보다 작은 수를 저장할 때 발생하는 현상
```
	


---

## ▶️ 참조 타입(reference type)
	객체의 주소를 저장, 8개의 기본형을 제외한 나머지 타입.
    무언가를 저장할 때, 저장하고자 하는 것이 존재하는 위치를 저장.

> - 어떤 값이 저장된 주소를 값으로 갖는다.
	(=데이터가 저장된 곳을 나타내는 주소값이 저장된다.)
- 빈 객체를 의미하는 'Null'이 존재한다.
- 힙(Heap) 메모리에 저장된다.
- 문법 상으로는 에러가 없지만 실행시켰을 때 에러가 나는 런타임 에러가 난다. 
	ex) 객체나 배열을 Null값으로 받으면 NullPointException이 발생하므로 변수값을 넣어야 한다.

![](https://velog.velcdn.com/images/bokimy/post/396c2cbc-a056-45e6-8bc3-6d81a3834c06/image.png)



---
**🟪 예시**
```java
public class Example {
    public static void main(String[] args) {
        int primitive = 1;
        Object reference = new Object(); //객체 저장
		//참조타입 변수 = 객체;
        
        System.out.println(primitive);
        System.out.println(reference);
    }
}
```
=> 실행 결과
```
...
> Task :Test.main()
1
java.lang.Object@626b2d4a //객체의 주소값
...
```
☾ primitive 변수 
: ``1`` 이라는 **값 그 자체** 저장.
=> 기본 타입은 값 그 자체가 변수에 저장되기 때문에 출력 결과는 ``기본타입변수``가 저장하고 있는 값 ``1``이 그대로 출력된다.

☾ reference 변수 
: 저장하고자 하는 것이 존재하는 위치를 저장. (like 주소).
객체를 어떤 변수에 저장한다면 그 변수에는 객체가 존재하는 메모리 ``주소를 값``으로 가진다. 즉, **주소값이 변수에 저장**.



---
cf)
래퍼 클래스
http://www.tcpschool.com/java/java_api_wrapper
타입
https://gbsb.tistory.com/144?category=735872



